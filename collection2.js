Meteor.Collection2 = function(name, options) {
    var self = this, userTransform, existingCollection;

    if (!(self instanceof Meteor.Collection2)) {
        throw new Error('use "new" to construct a Meteor.Collection2');
    }

    options = options || {};

    if (!("schema" in options)) {
        throw new Error('Meteor.Collection2 options must define a schema');
    }

    //set up simpleSchema
    if (options.schema instanceof SimpleSchema) {
        self._simpleSchema = options.schema;
    } else {
        self._simpleSchema = new SimpleSchema(options.schema, {
            additionalKeyPatterns: {
                forceValue: Match.Optional(Function),
                denyInsert: Match.Optional(Boolean),
                denyUpdate: Match.Optional(Boolean),
                unique: Match.Optional(Boolean)
            }
        });
    }
    delete options.schema;

    //store a generic validation context
    self._validationContexts = {
        "default": self._simpleSchema.newContext()
    };

    //get the virtual fields
    self._virtualFields = options.virtualFields;
    if ("virtualFields" in options) {
        delete options.virtualFields;
    }

    //populate _denyUpdateKeys, _denyInsertKeys and _forceValues
    self._denyInsertKeys = [];
    self._denyUpdateKeys = [];
    self._forceValues = {insert: {}, update: {}};
    _.each(self._simpleSchema.schema(), function (definition, fieldName) {
        if (definition.denyInsert === true) {
            self._denyInsertKeys.push(fieldName);
        }
        if (definition.denyUpdate === true) {
            self._denyUpdateKeys.push(fieldName);
        }
        if ('forceValue' in definition) {
            if (typeof definition.forceValue !== 'function')
                throw new Error('forceValue option must be a function')
            if (definition.denyUpdate !== true)
                self._forceValues.update[fieldName] = definition.forceValue;
            if (definition.denyInsert !== true)
                self._forceValues.insert[fieldName] = definition.forceValue;
        }
    });

    //create or update the collection
    if (name instanceof Meteor.Collection || ("SmartCollection" in Meteor && name instanceof Meteor.SmartCollection)) {
        existingCollection = name;
        //set up virtual fields
        if (self._virtualFields) {
            userTransform = existingCollection._transform;
            options.transform = function(doc) {
                //add all virtual fields to document whenever it's passed to a callback
                _.each(self._virtualFields, function(func, fieldName, list) {
                    doc[fieldName] = func(doc);
                });
                //support user-supplied transformation function as well
                return userTransform ? userTransform(doc) : doc;
            };
            existingCollection._transform = Deps._makeNonreactive(options.transform);
        }
        //update the collection
        self._name = existingCollection._name;
        self._collection = existingCollection;
    } else {
        //set up virtual fields
        if (self._virtualFields) {
            userTransform = options.transform;
            options.transform = function(doc) {
                //add all virtual fields to document whenever it's passed to a callback
                _.each(self._virtualFields, function(func, fieldName, list) {
                    doc[fieldName] = func(doc);
                });
                //support user-supplied transformation function as well
                return userTransform ? userTransform(doc) : doc;
            };
        }
        //create the collection
        self._name = name;
        var useSmart;
        if ("smart" in options) {
            useSmart = options.smart;
            delete options.smart;
        }
        if (useSmart === true && "SmartCollection" in Meteor) {
            self._collection = new Meteor.SmartCollection(name, options);
        } else {
            self._collection = new Meteor.Collection(name, options);
        }
    }
    //Validate from the real collection, too.
    //This prevents doing C2._collection.insert(invalidDoc) (and update) on the client
    self._collection.deny({
        insert: function(userId, doc) {
            // At this point the _id has been autogenerated and added to doc,
            // and any virtual fields have been added,
            // which makes it different from what we validated on the client.
            // Clone doc, remove _id and virtual fields, and validate the clone
            var docCopy = _.clone(doc);
            if ("_id" in docCopy && !self._simpleSchema.allowsKey("_id")) {
                //remove _id only if _id doesn't have a definition in the schema
                delete docCopy["_id"];
            }
            if (self._virtualFields) {
                _.each(self._virtualFields, function(func, fieldName) {
                    if (fieldName in docCopy) {
                        delete docCopy[fieldName];
                    }
                });
            }
            
            _.each(self._denyInsertKeys, function(key) {
                if (key in doc)
                    return false
            });
            //get a throwaway context here to avoid mixing up contexts
            var context = self._simpleSchema.newContext();
            context.validate(docCopy);
            return !context.isValid();
        },
        update: function(userId, doc, fields, modifier) {
            _.each(self._denyUpdateKeys, function(key) {
                if (key in fields)
                    return false
            });
            //get a throwaway context here to avoid mixing up contexts
            var context = self._simpleSchema.newContext();
            context.validate(modifier, {modifier: true});
            return !context.isValid();
        },
        fetch: []
    });
    //set up check for uniqueness
    self._simpleSchema.validator(function(key, val, def) {
        if (def.unique) {
            var test = {};
            test[key] = val;
            return self._collection.findOne(test) ? "notUnique" : true;
        }
    });
};

Meteor.Collection2.prototype._insertOrUpdate = function(type, args) {
    var self = this,
            collection = self._collection,
            schema = self._simpleSchema,
            context, doc, callback, error, options;

    if (!args.length) {
        throw new Error(type + " requires an argument");
    }

    if (type === "insert") {
        doc = args[0];
        options = args[1];
    } else if (type === "update") {
        doc = args[1];
        options = args[2];
    } else {
        throw new Error("invalid type argument");
    }

    //determine which validation context to use
    if (options === void 0 || options instanceof Function || !_.isObject(options) || typeof options.validationContext !== "string") {
        context = "default";
    } else {
        context = options.validationContext;
        ensureContext(self, context);
    }

    //remove the options from insert now that we're done with them
    if (type === "insert" && args[1] !== void 0 && !(args[1] instanceof Function)) {
        args.splice(1, 1);
    }

    //figure out callback situation
    if (args.length && args[args.length - 1] instanceof Function) {
        callback = args[args.length - 1];
    }
    if (Meteor.isClient && !callback) {
        // Client can't block, so it can't report errors by exception,
        // only by callback. If they forget the callback, give them a
        // default one that logs the error, so they aren't totally
        // baffled if their writes don't work because their database is
        // down.
        callback = function(err) {
            if (err)
                Meteor._debug(type + " failed: " + (err.reason || err.stack));
        };
    }

    //clean up doc
    doc = schema.clean(doc);

    //call and populate `forceValue` fields in the doc
    _.each(self._forceValues[type], function (func, fieldName) {
        var forceValue = func(doc, type);
        
        if (forceValue === undefined)
            return

        if (type === "insert")
            doc[fieldName] = forceValue;

        else if (type === "update") {
            var mongoModifier = false;
            
            // If forceValue is a mongoModifier like {$inc: 1}, we update the document to have
            // {$inc: {fieldName: 1}}
            _.each(['$inc', '$push', '$addToSet', '$pull', '$pop', '$slice'], function($elm) {
                if (forceValue.hasOwnProperty($elm)){
                    if (!($elm in doc))
                        doc[$elm] = {};
                    doc[$elm][fieldName] = {}[fieldName] = forceValue[$elm];
                    mongoModifier = true;
                }
            });
            // If forceValue isn't a mongoModifier but a simple object like a string, a number or
            // an array, we do a {$set: {fieldName: forceValue}}
            if (!mongoModifier) {
                if (!('$set' in doc))
                    doc.$set = {};
                doc.$set[fieldName] = forceValue;
            }
        }
    });

    //validate doc
    self._validationContexts[context].validate(doc, {modifier: (type === "update")});

    if (self._validationContexts[context].isValid()) {
        if (type === "insert") {
            args[0] = doc; //update to reflect cleaned doc
            return collection.insert.apply(collection, args);
        } else {
            args[1] = doc; //update to reflect cleaned doc
            return collection.update.apply(collection, args);
        }
    } else {
        error = new Error("failed validation");
        if (callback) {
            callback(error);
            return null;
        }
        throw error;
    }
};

Meteor.Collection2.prototype.insert = function(/* arguments */) {
    var args = _.toArray(arguments);
    return this._insertOrUpdate("insert", args);
};

Meteor.Collection2.prototype.update = function(/* arguments */) {
    var args = _.toArray(arguments);
    return this._insertOrUpdate("update", args);
};

Meteor.Collection2.prototype.simpleSchema = function() {
    return this._simpleSchema;
};

Meteor.Collection2.prototype.namedContext = function(name) {
    var self = this;
    ensureContext(self, name);
    return self._validationContexts[name];
};

Meteor.Collection2.prototype.validate = function(doc, options) {
    var self = this, schema = self._simpleSchema;

    //figure out the validation context name and make sure it exists
    var context = _.isObject(options) && typeof options.validationContext === "string" ? options.validationContext : "default";
    ensureContext(self, context);

    //clean doc
    doc = schema.clean(doc);
    //validate doc
    self._validationContexts[context].validate(doc, options);

    return self._validationContexts[context].isValid();
};

Meteor.Collection2.prototype.validateOne = function(doc, keyName, options) {
    var self = this, schema = self._simpleSchema;

    //figure out the validation context name and make sure it exists
    var context = _.isObject(options) && typeof options.validationContext === "string" ? options.validationContext : "default";
    ensureContext(self, context);

    //clean doc
    doc = schema.clean(doc);
    //validate doc
    self._validationContexts[context].validateOne(doc, keyName, options);

    return !self._validationContexts[context].keyIsInvalid(keyName);
};

//Pass-through Methods

Meteor.Collection2.prototype.remove = function(/* arguments */) {
    var self = this, collection = self._collection;
    return collection.remove.apply(collection, arguments);
};

Meteor.Collection2.prototype.allow = function(/* arguments */) {
    var self = this, collection = self._collection;
    return collection.allow.apply(collection, arguments);
};

Meteor.Collection2.prototype.deny = function(/* arguments */) {
    var self = this, collection = self._collection;
    return collection.deny.apply(collection, arguments);
};

Meteor.Collection2.prototype.find = function(/* arguments */) {
    var self = this, collection = self._collection;
    return collection.find.apply(collection, arguments);
};

Meteor.Collection2.prototype.findOne = function(/* arguments */) {
    var self = this, collection = self._collection;
    return collection.findOne.apply(collection, arguments);
};

//Private Methods

var ensureContext = function(c2, name) {
    c2._validationContexts[name] = c2._validationContexts[name] || c2._simpleSchema.newContext();
};
